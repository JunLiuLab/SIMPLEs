% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EM_impute.R
\name{EM_impute}
\alias{EM_impute}
\title{Monte Carlo EM algorithm for imputation and clustering}
\usage{
EM_impute(
  Y,
  Y0,
  pg,
  M0,
  K0,
  cutoff,
  iter,
  beta,
  sigma,
  lambda,
  pi,
  z,
  mu = NULL,
  celltype = NULL,
  penl = 1,
  est_z = 2,
  max_lambda = T,
  est_lam = 2,
  impt_it = 5,
  sigma0 = 100,
  pi_alpha = 1,
  verbose = F,
  num_mc = 3,
  lower = -Inf,
  upper = Inf
)
}
\arguments{
\item{Y}{An initial imputed gene expression matrix.}

\item{Y0}{Original scRNASeq data matrix.}

\item{pg}{A matrix for dropout rate of each cell type. Each row is a gene,
each column is the dropout rate of a cell type. The columns should be
ordered as the cell type label in \emph{clus}.}

\item{M0}{Number of clusters.}

\item{K0}{Number of latent gene modules.}

\item{cutoff}{The value below cutoff is treated as no expression.}

\item{iter}{Number of EM steps.}

\item{beta}{A G by K0 matrix. Initial values for factor loadings (B). See
details.}

\item{sigma}{A G by M0 matrix. Initial values for the variance of
idiosyncratic noises. Each column is for a cell cluster. See details.}

\item{lambda}{A M0 by K0 matrix. Initial values for the variances of factors.
Each column is for a cell cluster. See details.}

\item{pi}{A vector for initial probabilites of cells belong to each cluster.}

\item{z}{A n by M0 matrix for the probability of each cell belonging to each
cluster. Can be initialized as the one-hot encoding of cluster membership
of cells. If null, z will be updated in the first iteration.}

\item{mu}{A G by M0 matrix. Initial values for the gene expression mean of
each cluster. Each column is for a cell cluster. If NULL, it will take the
sample mean of cells weighted by the probability in each cluster. See
details.}

\item{celltype}{A numeric vector for labels of cells in the scRNASeq. Each
cell type has different dropout rate. If input bulk RNASeq data, each cell
type has corresponding mean expression in the bulk RNASeq data. The labels
must start from 1 to the number of types. If NULL, all cells are treated as
a single cell type.}

\item{penl}{L1 penalty for the factor loadings.}

\item{est_z}{The iteration starts to update z.}

\item{max_lambda}{Whether to maximize over lambda.}

\item{est_lam}{The iteration starts to estimate lambda.}

\item{impt_it}{The iteration starts to sample new imputed values.}

\item{sigma0}{The variance of the prior distribution of \eqn{\mu}.}

\item{pi_alpha}{The hyperparameter of the prior distribution of \eqn{\pi}.
See details.}

\item{verbose}{Whether to show some intermediate results. Default = False.}
}
\value{
\code{EM_impute} returns a list of results in the following order.
\enumerate{
\item{loglik}{The log-likelihood of the imputed gene expression at each iteration.}
\item{pi}{Probabilites of cells belong to each cluster.}
\item{mu}{Mean expression for each cluster.}
\item{sigma}{Variances of idiosyncratic noises for each cluster.}
\item{beta}{Factor loadings.}
\item{lambda}{Variances of factors for each cluster.}
\item{z}{The probability of each cell belonging to each cluster.}
\item{Ef}{Conditonal expection the factors for each cluster \eqn{E(f_i|z_i = m)}. A list with length M0, each element in the list is a n by K0 matrix.}
\item{Varf}{Conditonal covariance of factors for each cluster \eqn{Var(f_i|z_i = m)}. A list with length M0, each element in the list is a K0 by K0 matrix.}
\item{Y}{Last sample of imputed matrix.}
\item{geneM}{Overall mean of each gene expression. See details. } %Need to scale Y back to get the imputed expression matrix.
\item{geneSd}{Equal to 1 for each gene.}
}
}
\description{
Monte Carlo EM algorithm to sample the imputed values, cluster the
cells and learn the correlation structure of genes in each cluster.
}
\details{
Suppose there are G genes and n cells. For each cell cluster, the gene
  expression follows \eqn{Y|Z=m~MVN(\mu_m, B\Lambda_m B^T + \Sigma_m)} where
  B is a G by K0 matrix, \eqn{\Sigma_m} is a G by G diagonal matrix whose
  diagonal entries are specified by \emph{sigma}, and \eqn{\Lambda_m} is a K0
  by K0 diagonal matrix whose diagonal entries are specified by
  \emph{lambda}. \eqn{P(Z_m) = \pi_m} where \eqn{\pi~Dir(\alpha)}. We remove
  the overall mean of each gene before running the algorithm and all the
  parameters are estimated based on the normalized gene expression matrix.
  The overall mean is returned as \emph{geneM}.
}
\author{
Zhirui Hu, \email{zhiruihu@g.harvard.edu}

Songpeng Zu, \email{songpengzu@g.harvard.edu}
}
